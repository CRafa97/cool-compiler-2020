\__ProgramNode [<class> ... <class>]
	\__ClassDeclarationNode: class Graph  { <feature> ... <feature> }
		\__AttrDeclarationNode: vertices : VList
		\__AttrDeclarationNode: edges : EList
		\__FuncDeclarationNode: add_vertice(v:Vertice) : Object -> <body>
			\__ BlockNode { <expr_list> }
				\__AssignNode: edges <- <expr>
					\__ExprCallNode: <obj>.append(<expr>, ..., <expr>)
						\__ExprCallNode: <obj>.outgoing(<expr>, ..., <expr>)
							\__ VarAccessNode: v

						\__ VarAccessNode: edges
				\__AssignNode: vertices <- <expr>
					\__ExprCallNode: <obj>.cons(<expr>, ..., <expr>)
						\__ VarAccessNode: vertices
						\__ VarAccessNode: v
		\__FuncDeclarationNode: print_E() : Object -> <body>
			\__ExprCallNode: <obj>.print(<expr>, ..., <expr>)
				\__ VarAccessNode: edges

		\__FuncDeclarationNode: print_V() : Object -> <body>
			\__ExprCallNode: <obj>.print(<expr>, ..., <expr>)
				\__ VarAccessNode: vertices

	\__ClassDeclarationNode: class Vertice : IO { <feature> ... <feature> }
		\__AttrDeclarationNode: num : Int
		\__AttrDeclarationNode: out : EList
		\__FuncDeclarationNode: outgoing() : EList -> <body>
			\__ VarAccessNode: out
		\__FuncDeclarationNode: number() : Int -> <body>
			\__ VarAccessNode: num
		\__FuncDeclarationNode: init(n:Int) : Vertice -> <body>
			\__ BlockNode { <expr_list> }
				\__AssignNode: num <- <expr>
					\__ VarAccessNode: n
				\__ VarAccessNode: self
		\__FuncDeclarationNode: add_out(s:Edge) : Vertice -> <body>
			\__ BlockNode { <expr_list> }
				\__AssignNode: out <- <expr>
					\__ExprCallNode: <obj>.cons(<expr>, ..., <expr>)
						\__ VarAccessNode: out
						\__ VarAccessNode: s
				\__ VarAccessNode: self
		\__FuncDeclarationNode: print() : Object -> <body>
			\__ BlockNode { <expr_list> }
				\__SelfCallNode: out_int(<expr>, ..., <expr>)
					\__ VarAccessNode: num
				\__ExprCallNode: <obj>.print(<expr>, ..., <expr>)
					\__ VarAccessNode: out

	\__ClassDeclarationNode: class Edge : IO { <feature> ... <feature> }
		\__AttrDeclarationNode: from : Int
		\__AttrDeclarationNode: to : Int
		\__AttrDeclarationNode: weight : Int
		\__FuncDeclarationNode: init(f:Int, t:Int, w:Int) : Edge -> <body>
			\__ BlockNode { <expr_list> }
				\__AssignNode: from <- <expr>
					\__ VarAccessNode: f
				\__AssignNode: to <- <expr>
					\__ VarAccessNode: t
				\__AssignNode: weight <- <expr>
					\__ VarAccessNode: w
				\__ VarAccessNode: self
		\__FuncDeclarationNode: print() : Object -> <body>
			\__ BlockNode { <expr_list> }
				\__SelfCallNode: out_string(<expr>, ..., <expr>)
					\__ StringNode:  (
				\__SelfCallNode: out_int(<expr>, ..., <expr>)
					\__ VarAccessNode: from
				\__SelfCallNode: out_string(<expr>, ..., <expr>)
					\__ StringNode: ,
				\__SelfCallNode: out_int(<expr>, ..., <expr>)
					\__ VarAccessNode: to
				\__SelfCallNode: out_string(<expr>, ..., <expr>)
					\__ StringNode: )
				\__SelfCallNode: out_int(<expr>, ..., <expr>)
					\__ VarAccessNode: weight
	\__ClassDeclarationNode: class EList : IO { <feature> ... <feature> }
		\__AttrDeclarationNode: car : Edge
		\__FuncDeclarationNode: isNil() : Bool -> <body>
			\__ BoolNode: True
		\__FuncDeclarationNode: head() : Edge -> <body>
			\__ BlockNode { <expr_list> }
				\__SelfCallNode: abort(<expr>, ..., <expr>)

				\__ VarAccessNode: car
		\__FuncDeclarationNode: tail() : EList -> <body>
			\__ BlockNode { <expr_list> }
				\__SelfCallNode: abort(<expr>, ..., <expr>)

				\__ VarAccessNode: self
		\__FuncDeclarationNode: cons(e:Edge) : EList -> <body>
			\__ExprCallNode: <obj>.init(<expr>, ..., <expr>)
				\__ InstantiateNode: new ECons()
				\__ VarAccessNode: e
				\__ VarAccessNode: self
		\__FuncDeclarationNode: append(l:EList) : EList -> <body>
			\__ ConditionalNode: if <cond> then <expr> else <expr> fi
				\__ExprCallNode: <obj>.isNil(<expr>, ..., <expr>)
					\__ VarAccessNode: self

				\__ VarAccessNode: l
				\__ExprCallNode: <obj>.cons(<expr>, ..., <expr>)
					\__ExprCallNode: <obj>.append(<expr>, ..., <expr>)
						\__SelfCallNode: tail(<expr>, ..., <expr>)

						\__ VarAccessNode: l
					\__SelfCallNode: head(<expr>, ..., <expr>)

		\__FuncDeclarationNode: print() : Object -> <body>
			\__SelfCallNode: out_string(<expr>, ..., <expr>)
				\__ StringNode: \n
	\__ClassDeclarationNode: class ECons : EList { <feature> ... <feature> }
		\__AttrDeclarationNode: cdr : EList
		\__FuncDeclarationNode: isNil() : Bool -> <body>
			\__ BoolNode: False
		\__FuncDeclarationNode: head() : Edge -> <body>
			\__ VarAccessNode: car
		\__FuncDeclarationNode: tail() : EList -> <body>
			\__ VarAccessNode: cdr
		\__FuncDeclarationNode: init(e:Edge, rest:EList) : EList -> <body>
			\__ BlockNode { <expr_list> }
				\__AssignNode: car <- <expr>
					\__ VarAccessNode: e
				\__AssignNode: cdr <- <expr>
					\__ VarAccessNode: rest
				\__ VarAccessNode: self
		\__FuncDeclarationNode: print() : Object -> <body>
			\__ BlockNode { <expr_list> }
				\__ExprCallNode: <obj>.print(<expr>, ..., <expr>)
					\__ VarAccessNode: car

				\__ExprCallNode: <obj>.print(<expr>, ..., <expr>)
					\__ VarAccessNode: cdr

	\__ClassDeclarationNode: class VList : IO { <feature> ... <feature> }
		\__AttrDeclarationNode: car : Vertice
		\__FuncDeclarationNode: isNil() : Bool -> <body>
			\__ BoolNode: True
		\__FuncDeclarationNode: head() : Vertice -> <body>
			\__ BlockNode { <expr_list> }
				\__SelfCallNode: abort(<expr>, ..., <expr>)

				\__ VarAccessNode: car
		\__FuncDeclarationNode: tail() : VList -> <body>
			\__ BlockNode { <expr_list> }
				\__SelfCallNode: abort(<expr>, ..., <expr>)

				\__ VarAccessNode: self
		\__FuncDeclarationNode: cons(v:Vertice) : VList -> <body>
			\__ExprCallNode: <obj>.init(<expr>, ..., <expr>)
				\__ InstantiateNode: new VCons()
				\__ VarAccessNode: v
				\__ VarAccessNode: self
		\__FuncDeclarationNode: print() : Object -> <body>
			\__SelfCallNode: out_string(<expr>, ..., <expr>)
				\__ StringNode: \n
	\__ClassDeclarationNode: class VCons : VList { <feature> ... <feature> }
		\__AttrDeclarationNode: cdr : VList
		\__FuncDeclarationNode: isNil() : Bool -> <body>
			\__ BoolNode: False
		\__FuncDeclarationNode: head() : Vertice -> <body>
			\__ VarAccessNode: car
		\__FuncDeclarationNode: tail() : VList -> <body>
			\__ VarAccessNode: cdr
		\__FuncDeclarationNode: init(v:Vertice, rest:VList) : VList -> <body>
			\__ BlockNode { <expr_list> }
				\__AssignNode: car <- <expr>
					\__ VarAccessNode: v
				\__AssignNode: cdr <- <expr>
					\__ VarAccessNode: rest
				\__ VarAccessNode: self
		\__FuncDeclarationNode: print() : Object -> <body>
			\__ BlockNode { <expr_list> }
				\__ExprCallNode: <obj>.print(<expr>, ..., <expr>)
					\__ VarAccessNode: car

				\__ExprCallNode: <obj>.print(<expr>, ..., <expr>)
					\__ VarAccessNode: cdr

	\__ClassDeclarationNode: class Parse : IO { <feature> ... <feature> }
		\__AttrDeclarationNode: boolop : BoolOp
		\__FuncDeclarationNode: read_input() : Graph -> <body>
			\__ LetNode let <init_list> in <expr>
				\__VarDeclarationNode: g : Graph = <expr>
					\__ InstantiateNode: new Graph()
				\__ BlockNode { <expr_list> }
					\__ LetNode let <init_list> in <expr>
						\__VarDeclarationNode: line : String = <expr>
							\__SelfCallNode: in_string(<expr>, ..., <expr>)

						\__WhileNode: while <cond> loop <expr> pool
							\__ExprCallNode: <obj>.and(<expr>, ..., <expr>)
								\__ VarAccessNode: boolop
								\__<expr> EqualNode <expr>
									\__NotNode <expr>
										\__ VarAccessNode: line
									\__ StringNode: \n
								\__<expr> EqualNode <expr>
									\__NotNode <expr>
										\__ VarAccessNode: line
									\__ StringNode: 
							\__ BlockNode { <expr_list> }
								\__ExprCallNode: <obj>.add_vertice(<expr>, ..., <expr>)
									\__ VarAccessNode: g
									\__SelfCallNode: parse_line(<expr>, ..., <expr>)
										\__ VarAccessNode: line
								\__AssignNode: line <- <expr>
									\__SelfCallNode: in_string(<expr>, ..., <expr>)

					\__ VarAccessNode: g
		\__FuncDeclarationNode: parse_line(s:String) : Vertice -> <body>
			\__ LetNode let <init_list> in <expr>
				\__VarDeclarationNode: v : Vertice = <expr>
					\__ExprCallNode: <obj>.init(<expr>, ..., <expr>)
						\__ InstantiateNode: new Vertice()
						\__SelfCallNode: a2i(<expr>, ..., <expr>)
							\__ VarAccessNode: s
				\__ BlockNode { <expr_list> }
					\__WhileNode: while <cond> loop <expr> pool
						\__<expr> EqualNode <expr>
							\__NotNode <expr>
								\__ExprCallNode: <obj>.length(<expr>, ..., <expr>)
									\__ VarAccessNode: rest

							\__ IntegerNode: 0
						\__ BlockNode { <expr_list> }
							\__ LetNode let <init_list> in <expr>
								\__VarDeclarationNode: succ : Int = <expr>
									\__SelfCallNode: a2i(<expr>, ..., <expr>)
										\__ VarAccessNode: rest
								\__ LetNode let <init_list> in <expr>
									\__VarDeclarationNode: weight : Int = <expr>
										\__SelfCallNode: a2i(<expr>, ..., <expr>)
											\__ VarAccessNode: rest
									\__ExprCallNode: <obj>.add_out(<expr>, ..., <expr>)
										\__ VarAccessNode: v
										\__ExprCallNode: <obj>.init(<expr>, ..., <expr>)
											\__ InstantiateNode: new Edge()
											\__ExprCallNode: <obj>.number(<expr>, ..., <expr>)
												\__ VarAccessNode: v

											\__ VarAccessNode: succ
											\__ VarAccessNode: weight
					\__ VarAccessNode: v
		\__FuncDeclarationNode: c2i(char:String) : Int -> <body>
			\__ ConditionalNode: if <cond> then <expr> else <expr> fi
				\__<expr> EqualNode <expr>
					\__ VarAccessNode: char
					\__ StringNode: 0
				\__ IntegerNode: 0
				\__ ConditionalNode: if <cond> then <expr> else <expr> fi
					\__<expr> EqualNode <expr>
						\__ VarAccessNode: char
						\__ StringNode: 1
					\__ IntegerNode: 1
					\__ ConditionalNode: if <cond> then <expr> else <expr> fi
						\__<expr> EqualNode <expr>
							\__ VarAccessNode: char
							\__ StringNode: 2
						\__ IntegerNode: 2
						\__ ConditionalNode: if <cond> then <expr> else <expr> fi
							\__<expr> EqualNode <expr>
								\__ VarAccessNode: char
								\__ StringNode: 3
							\__ IntegerNode: 3
							\__ ConditionalNode: if <cond> then <expr> else <expr> fi
								\__<expr> EqualNode <expr>
									\__ VarAccessNode: char
									\__ StringNode: 4
								\__ IntegerNode: 4
								\__ ConditionalNode: if <cond> then <expr> else <expr> fi
									\__<expr> EqualNode <expr>
										\__ VarAccessNode: char
										\__ StringNode: 5
									\__ IntegerNode: 5
									\__ ConditionalNode: if <cond> then <expr> else <expr> fi
										\__<expr> EqualNode <expr>
											\__ VarAccessNode: char
											\__ StringNode: 6
										\__ IntegerNode: 6
										\__ ConditionalNode: if <cond> then <expr> else <expr> fi
											\__<expr> EqualNode <expr>
												\__ VarAccessNode: char
												\__ StringNode: 7
											\__ IntegerNode: 7
											\__ ConditionalNode: if <cond> then <expr> else <expr> fi
												\__<expr> EqualNode <expr>
													\__ VarAccessNode: char
													\__ StringNode: 8
												\__ IntegerNode: 8
												\__ ConditionalNode: if <cond> then <expr> else <expr> fi
													\__<expr> EqualNode <expr>
														\__ VarAccessNode: char
														\__ StringNode: 9
													\__ IntegerNode: 9
													\__ BlockNode { <expr_list> }
														\__SelfCallNode: abort(<expr>, ..., <expr>)

														\__ IntegerNode: 0
		\__AttrDeclarationNode: rest : String
		\__FuncDeclarationNode: a2i(s:String) : Int -> <body>
			\__ ConditionalNode: if <cond> then <expr> else <expr> fi
				\__<expr> EqualNode <expr>
					\__ExprCallNode: <obj>.length(<expr>, ..., <expr>)
						\__ VarAccessNode: s

					\__ IntegerNode: 0
				\__ IntegerNode: 0
				\__ ConditionalNode: if <cond> then <expr> else <expr> fi
					\__<expr> EqualNode <expr>
						\__ExprCallNode: <obj>.substr(<expr>, ..., <expr>)
							\__ VarAccessNode: s
							\__ IntegerNode: 0
							\__ IntegerNode: 1
						\__ StringNode: -
					\__BitNotNode <expr>
						\__SelfCallNode: a2i_aux(<expr>, ..., <expr>)
							\__ExprCallNode: <obj>.substr(<expr>, ..., <expr>)
								\__ VarAccessNode: s
								\__ IntegerNode: 1
								\__<expr> DiffNode <expr>
									\__ExprCallNode: <obj>.length(<expr>, ..., <expr>)
										\__ VarAccessNode: s

									\__ IntegerNode: 1
					\__ ConditionalNode: if <cond> then <expr> else <expr> fi
						\__<expr> EqualNode <expr>
							\__ExprCallNode: <obj>.substr(<expr>, ..., <expr>)
								\__ VarAccessNode: s
								\__ IntegerNode: 0
								\__ IntegerNode: 1
							\__ StringNode:  
						\__SelfCallNode: a2i(<expr>, ..., <expr>)
							\__ExprCallNode: <obj>.substr(<expr>, ..., <expr>)
								\__ VarAccessNode: s
								\__ IntegerNode: 1
								\__<expr> DiffNode <expr>
									\__ExprCallNode: <obj>.length(<expr>, ..., <expr>)
										\__ VarAccessNode: s

									\__ IntegerNode: 1
						\__SelfCallNode: a2i_aux(<expr>, ..., <expr>)
							\__ VarAccessNode: s
		\__FuncDeclarationNode: a2i_aux(s:String) : Int -> <body>
			\__ LetNode let <init_list> in <expr>
				\__VarDeclarationNode: int : Int = <expr>
					\__ IntegerNode: 0
				\__ BlockNode { <expr_list> }
					\__ LetNode let <init_list> in <expr>
						\__VarDeclarationNode: j : Int = <expr>
							\__ExprCallNode: <obj>.length(<expr>, ..., <expr>)
								\__ VarAccessNode: s

						\__ LetNode let <init_list> in <expr>
							\__VarDeclarationNode: i : Int = <expr>
								\__ IntegerNode: 0
							\__WhileNode: while <cond> loop <expr> pool
								\__<expr> LessNode <expr>
									\__ VarAccessNode: i
									\__ VarAccessNode: j
								\__ LetNode let <init_list> in <expr>
									\__VarDeclarationNode: c : String = <expr>
										\__ExprCallNode: <obj>.substr(<expr>, ..., <expr>)
											\__ VarAccessNode: s
											\__ VarAccessNode: i
											\__ IntegerNode: 1
									\__ ConditionalNode: if <cond> then <expr> else <expr> fi
										\__<expr> EqualNode <expr>
											\__ VarAccessNode: c
											\__ StringNode:  
										\__ BlockNode { <expr_list> }
											\__AssignNode: rest <- <expr>
												\__ExprCallNode: <obj>.substr(<expr>, ..., <expr>)
													\__ VarAccessNode: s
													\__<expr> SumNode <expr>
														\__ VarAccessNode: i
														\__ IntegerNode: 1
													\__<expr> DiffNode <expr>
														\__<expr> DiffNode <expr>
															\__ExprCallNode: <obj>.length(<expr>, ..., <expr>)
																\__ VarAccessNode: s

															\__ VarAccessNode: i
														\__ IntegerNode: 1
											\__AssignNode: i <- <expr>
												\__ VarAccessNode: j
										\__ ConditionalNode: if <cond> then <expr> else <expr> fi
											\__<expr> EqualNode <expr>
												\__ VarAccessNode: c
												\__ StringNode: ,
											\__ BlockNode { <expr_list> }
												\__AssignNode: rest <- <expr>
													\__ExprCallNode: <obj>.substr(<expr>, ..., <expr>)
														\__ VarAccessNode: s
														\__<expr> SumNode <expr>
															\__ VarAccessNode: i
															\__ IntegerNode: 1
														\__<expr> DiffNode <expr>
															\__<expr> DiffNode <expr>
																\__ExprCallNode: <obj>.length(<expr>, ..., <expr>)
																	\__ VarAccessNode: s

																\__ VarAccessNode: i
															\__ IntegerNode: 1
												\__AssignNode: i <- <expr>
													\__ VarAccessNode: j
											\__ BlockNode { <expr_list> }
												\__AssignNode: int <- <expr>
													\__<expr> StarNode <expr>
														\__ VarAccessNode: int
														\__<expr> SumNode <expr>
															\__ IntegerNode: 10
															\__SelfCallNode: c2i(<expr>, ..., <expr>)
																\__ExprCallNode: <obj>.substr(<expr>, ..., <expr>)
																	\__ VarAccessNode: s
																	\__ VarAccessNode: i
																	\__ IntegerNode: 1
												\__AssignNode: i <- <expr>
													\__<expr> SumNode <expr>
														\__ VarAccessNode: i
														\__ IntegerNode: 1
												\__ ConditionalNode: if <cond> then <expr> else <expr> fi
													\__<expr> EqualNode <expr>
														\__ VarAccessNode: i
														\__ VarAccessNode: j
													\__AssignNode: rest <- <expr>
														\__ StringNode: 
													\__ StringNode: 
					\__ VarAccessNode: int
	\__ClassDeclarationNode: class Main : Parse { <feature> ... <feature> }
		\__AttrDeclarationNode: g : Graph
		\__FuncDeclarationNode: main() : Object -> <body>
			\__ BlockNode { <expr_list> }
				\__ExprCallNode: <obj>.print_V(<expr>, ..., <expr>)
					\__ VarAccessNode: g

				\__ExprCallNode: <obj>.print_E(<expr>, ..., <expr>)
					\__ VarAccessNode: g

	\__ClassDeclarationNode: class BoolOp  { <feature> ... <feature> }
		\__FuncDeclarationNode: and(b1:Bool, b2:Bool) : Bool -> <body>
			\__ ConditionalNode: if <cond> then <expr> else <expr> fi
				\__ VarAccessNode: b1
				\__ VarAccessNode: b2
				\__ BoolNode: False
		\__FuncDeclarationNode: or(b1:Bool, b2:Bool) : Bool -> <body>
			\__ ConditionalNode: if <cond> then <expr> else <expr> fi
				\__ VarAccessNode: b1
				\__ BoolNode: True
				\__ VarAccessNode: b2